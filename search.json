[{"path":"https://qinhuang-poliecon.github.io/mlQCA/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 mlQCA authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://qinhuang-poliecon.github.io/mlQCA/articles/mlQCA.html","id":"overall-workflow","dir":"Articles","previous_headings":"","what":"1. Overall Workflow","title":"mlQCA","text":"overall workflow package intentionally straight-forward (assume pre-processed data calibrated yet): 1. Build xgboost model (classification based outcome label) 2. Estimate feature importance (based xgboost model SHAP analysis) 3. Extract cutoffs (used xgboost model) 4. Calibrate data (cutoffs generated Step 2) 5. Necessity analysis individual conditions (using calibrated data) 6. Form condition-ranking table (tallying feature importance necessity metrics) 7. Iterative QCA sufficiency analysis (choosing k explanatory conditions given n condition vector)","code":"## 1. Build an xgboost model xgb <- buildXGboost(voteData, \"vote\")  ## 2. estimate feature importance fMetricModel <- getFeatureImp(xgb, voteData, \"vote\")  ## 3. Extract cutoffs cutDf <- getXGboostCut(xgb, full = F)  ## 4. Calibrate data voteDataCalibrated <- reCalibrateXGCut(data = voteData, cutoffs = cutDf, outcome = \"vote\", na.rm = F)  ## 5. Necessity analysis for individual conditions fMetricQCA <- getQCAMetric(voteDataCalibrated, \"vote\")  ## 6. Form condition-ranking table fRankTable <- joinMetrics(fMetricModel, fMetricQCA)  ## 7. Iterative QCA for sufficiency analysis selectFeatures <- head(fMetricModel$feature, 10) Res <- iterQCA(features = selectFeatures, k=4, dataCali = voteDataCalibrated, outcome = \"vote\", incl.cut = 0.8)"},{"path":[]},{"path":"https://qinhuang-poliecon.github.io/mlQCA/articles/mlQCA.html","id":"build-an-xgboost-model","dir":"Articles","previous_headings":"2. Detailed Steps","what":"2.1 Build an xgboost model","title":"mlQCA","text":"assume pre-processed data (including data cleaning, renaming, filtering etc.), start building xgboost model. Specifically, build tree ensemble classification model classify observation one outcome category. example data voteData, outcome condition \"vote\", indicating whether interviewee voted . row interviewee, features various aspects interviewee (e.g. education level, parent education level, etc.). Refer codebook feature names. build xgboost model predict \"vote\" outcome. hood, built model using caret xgboost packages. see details default parameters used, call ?buildXGboost. can estimate accuracy model get idea well differentiates voters non-voters.Note goal predict new data, rather understand data hand. accuracy, even modest general classification model, may good enough show success using given features tell apart voters non-voters.","code":"dim(voteData) # 427 interviewees; 77 features, including \"vote\" #> [1] 427  77 table(voteData$vote) # 319 voted; 108 did not vote; #>  #>   0   1  #> 108 319 ## this can take a few minutes set.seed(201) ## ensure reproducibility xgb <- buildXGboost(voteData, \"vote\") getAccXGboost(xgb, voteData, \"vote\")  #> [1] 1"},{"path":"https://qinhuang-poliecon.github.io/mlQCA/articles/mlQCA.html","id":"estimate-feature-importance","dir":"Articles","previous_headings":"2. Detailed Steps","what":"2.2 Estimate feature importance","title":"mlQCA","text":"next use built xgboost model estimate relative importance feature differentiating voters non-voters. specifically, look four metrics: three extracted direclty xgboost tree ensemble (gain, cover, frequency) one additional calculated measure (shapley value). Briefly, meaning four metrics : Gain: improvement accuracy brought feature branches Cover: relative quantity observations concerned feature Frequency: number times feature used generated trees SHAP value (average): average contribution feature prediction model Detailed explanation measures, particularly Shapley values, scope , many sources online provide great explanations easily searchable.","code":"fMetricModel <- getFeatureImp(xgb, voteData, \"vote\") head(fMetricModel) #>   feature       Gain      Cover  Frequency      shap #> 1    V648 0.03230976 0.03431853 0.02008457 0.3786536 #> 2  P_V195 0.04122095 0.04229647 0.05073996 0.3667945 #> 3  P_V530 0.04155585 0.04892724 0.01479915 0.3489758 #> 4    V191 0.01959714 0.03495970 0.01374207 0.3418239 #> 5    V207 0.04996828 0.04374676 0.04228330 0.3047783 #> 6   P_V44 0.01707990 0.01998959 0.01374207 0.2811981"},{"path":"https://qinhuang-poliecon.github.io/mlQCA/articles/mlQCA.html","id":"extract-cutoffs","dir":"Articles","previous_headings":"2. Detailed Steps","what":"2.3 Extract Cutoffs","title":"mlQCA","text":"Since xgboost treen ensemble collection individual tree structures, can extract summarize cutoffs used across leverage cutoffs calibrate data. default behavior look feature’s cutoff across trees choose frequently used one. Admittedly, might appropriate cutoffs depending contexts, showed cutoffs, among possible cutoffs, produce QCA solutions among top 10%. Still, enourage users take guidance leverage prior/domain knowledge evaluate relavance appropriateness, modify accordingly. Another potential catch approach “missing features”. constructing model, certain built-randomness (selecting features tree), consequently features (usually less informative ones) may used. normally okay, “missing feautres” likely uninformative thus least useful downstream QCA analysis. However, certain features still desired, can manually add cutoff table set cutoff . Alternatively, can also set different seed retrain xgboost model see features selected.","code":"cutDf <- getXGboostCut(xgb, full = F) head(cutDf) #> # A tibble: 6 × 2 #>   feature cutoff #>   <chr>    <dbl> #> 1 P_V136     3.5 #> 2 P_V168     2.5 #> 3 P_V185     0.5 #> 4 P_V195    52.5 #> 5 P_V242     3.5 #> 6 P_V243     3.5 nrow(cutDf) # 72 of the 76 features selected; 4 \"missing\" features #> [1] 73"},{"path":"https://qinhuang-poliecon.github.io/mlQCA/articles/mlQCA.html","id":"calibrate-data","dir":"Articles","previous_headings":"2. Detailed Steps","what":"2.4 Calibrate data","title":"mlQCA","text":"building xgboost model, require enourage input data calibrated. ensures maximal details/information can instrumental classification. However, proceed downstream QCA tasks, calibrate data. Since extracted cutoffs , can use directly calibrate. Note current version support crisp calibration, fuzzy set calibration supported future versions.","code":"## before calibration unique(voteData$V188) #>  [1] 16 11 10 14  5 18  8  7  6  4 25  3  0  2 15 30 13 12 27 20  9 22 24  1 35 #> [26] 28 17 23 ## calibrate voteDataCalibrated <- reCalibrateXGCut(data = voteData, cutoffs = cutDf, outcome = \"vote\", na.rm = F) ## after calibration unique(voteDataCalibrated$V188) #> [1] 1 0"},{"path":"https://qinhuang-poliecon.github.io/mlQCA/articles/mlQCA.html","id":"necessity-analysis-for-individual-conditions","dir":"Articles","previous_headings":"2. Detailed Steps","what":"2.5 Necessity analysis for individual conditions","title":"mlQCA","text":"Now (re)calibrated data, can perform QCA necessity test get idea necessity relationship explanatory condition outcome.","code":"fMetricQCA <- getQCAMetric(voteDataCalibrated, \"vote\") head(fMetricQCA) #>        Cons.Nec Cov.Nec   RoN feature #> P_V136    0.574   0.769 0.775  P_V136 #> P_V168    0.473   0.737 0.804  P_V168 #> P_V185    0.429   0.721 0.817  P_V185 #> P_V195    0.411   0.780 0.875  P_V195 #> P_V242    0.545   0.753 0.775  P_V242 #> P_V243    0.473   0.702 0.768  P_V243"},{"path":"https://qinhuang-poliecon.github.io/mlQCA/articles/mlQCA.html","id":"form-condition-ranking-table","dir":"Articles","previous_headings":"2. Detailed Steps","what":"2.6 Form condition-ranking table","title":"mlQCA","text":"constructed per-feature metrics xgboost model QCA necessity tests, can combine get single feature importance table save later reference. Note final ranking fRank still based “shap” value, best captures learning xgboost model.","code":"fRankTable <- joinMetrics(fMetricModel, fMetricQCA) head(fRankTable) #>   feature       Gain      Cover  Frequency      shap Cons.Nec Cov.Nec   RoN #> 1    V648 0.03230976 0.03431853 0.02008457 0.3786536   0.7490  0.8100 0.702 #> 2  P_V195 0.04122095 0.04229647 0.05073996 0.3667945   0.4110  0.7800 0.875 #> 3  P_V530 0.04155585 0.04892724 0.01479915 0.3489758   0.0846  0.4737 0.925 #> 4    V191 0.01959714 0.03495970 0.01374207 0.3418239   0.2100  0.8590 0.969 #> 5    V207 0.04996828 0.04374676 0.04228330 0.3047783   0.3790  0.8580 0.935 #> 6   P_V44 0.01707990 0.01998959 0.01374207 0.2811981   0.3860  0.8260 0.914 #>   fRank #> 1     1 #> 2     2 #> 3     3 #> 4     4 #> 5     5 #> 6     6"},{"path":"https://qinhuang-poliecon.github.io/mlQCA/articles/mlQCA.html","id":"iterative-qca","dir":"Articles","previous_headings":"2. Detailed Steps","what":"2.7 Iterative QCA","title":"mlQCA","text":"condition ranking great reference, shown top features average provide much better QCA solutions bottom ones. However, even among top 10, normally want choose 3 4 features analyze using QCA. presents problem know 3 4 10 features might give us best solution. address , perform iterative QCA sufficiency tests summarize results. Specifically, example, let’s choose top 10 features feature ranking table “pool” features. iteratively choose 4 10 features QCA analysis, exhaustively examining combinations “10-choose-4”. resulting solutions include particular combination 4 features, corresponding solution metric scores solution. addition, results also ranked based coverage guidance. Users encouraged examine table determine best features use. Note features choose manually determined users, need top features form ranking table.","code":"selectFeatures <- head(fMetricModel$feature, 10) ## this can take a few minutes Res <- iterQCA(features = selectFeatures, k=4, dataCali = voteDataCalibrated, outcome = \"vote\", incl.cut = 0.8) head(Res) #>                    features                                   path     inclS #> 1   V648,P_V195,P_V530,V191      V648*~P_V530+~P_V195*~P_V530*V191 0.8380282 #> 2 P_V195,P_V530,P_V44,P_V59           ~P_V530*P_V44+~P_V530*~P_V59 0.8292683 #> 3  P_V195,P_V530,V189,P_V59     ~P_V530*~P_V59+P_V195*~P_V530*V189 0.8233216 #> 4   P_V195,P_V530,V141,V204 ~P_V195*~P_V530*V141+~P_V530*V141*V204 0.8376384 #> 5    V648,P_V530,P_V44,V141   V648*~P_V530*V141+~P_V530*P_V44*V141 0.8401487 #> 6   V648,P_V195,P_V530,V189                           V648*~P_V530 0.8383459 #>         PRI     convS rank #> 1 0.8380282 0.7460815    1 #> 2 0.8292683 0.7460815    2 #> 3 0.8233216 0.7304075    3 #> 4 0.8376384 0.7115987    4 #> 5 0.8401487 0.7084639    5 #> 6 0.8383459 0.6990596    6"},{"path":"https://qinhuang-poliecon.github.io/mlQCA/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Qin Huang. Maintainer.","code":""},{"path":"https://qinhuang-poliecon.github.io/mlQCA/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Huang Q (2023). mlQCA: Machine-learning-enhanced QCA. https://github.com/qinhuang-poliecon/mlQCA, https://qinhuang-poliecon.github.io/mlQCA/.","code":"@Manual{,   title = {mlQCA: Machine-learning-enhanced QCA},   author = {Qin Huang},   year = {2023},   note = {https://github.com/qinhuang-poliecon/mlQCA, https://qinhuang-poliecon.github.io/mlQCA/}, }"},{"path":"https://qinhuang-poliecon.github.io/mlQCA/index.html","id":"mlqcamachine-learning-enhanced-qualitative-comparative-analysis-qca-","dir":"","previous_headings":"","what":"Machine-learning-enhanced QCA","title":"Machine-learning-enhanced QCA","text":"mlQCA R package designed empower researchers capabilities machine learning (ML) conducting qualitative comparative analysis (QCA) effectively. package specifically addresses limitations QCA large datasets incorporating ML-enhanced condition selection calibration. core, mlQCA utilizes extreme gradient boosting (XGBoost) tree ensemble algorithm classification based outcome, assisting practitioners finding explanatory conditions calibration cut-offs optimize coverage QCA solutions. Furthermore, package provides ability iteratively evaluate QCA across range conditions, allowing -depth analysis.","code":""},{"path":"https://qinhuang-poliecon.github.io/mlQCA/index.html","id":"package-installation","dir":"","previous_headings":"","what":"Package Installation","title":"Machine-learning-enhanced QCA","text":"package currently hosted github users can install directly github:","code":"devtools::install_github(\"qinhuang_poliecon/mlQCA\")"},{"path":"https://qinhuang-poliecon.github.io/mlQCA/index.html","id":"test-the-package","dir":"","previous_headings":"","what":"Test the package","title":"Machine-learning-enhanced QCA","text":"Load sample data test installation:","code":"library(mlQCA) xgb <- buildXGboost(voteData, \"vote\") fMetricModel <- getFeatureImp(xgb, voteData, \"vote\") plot(xgb) head(fMetricModel)"},{"path":"https://qinhuang-poliecon.github.io/mlQCA/index.html","id":"vignettes-and-examples","dir":"","previous_headings":"","what":"Vignettes and examples","title":"Machine-learning-enhanced QCA","text":"build vignettes Celda DecontX installation GitHub, use following command: Note installation may take extra 5-10 minutes building vignettes. Celda DecontX vignettes can accessed via following commands: Detailed documentation workflow tutorial can found mlQCA package site.","code":"library(devtools) install_github(\"qinhuang_poliecon/mlQCA\", build_vignettes = TRUE) vignette(\"celda\")"},{"path":"https://qinhuang-poliecon.github.io/mlQCA/index.html","id":"get-help","dir":"","previous_headings":"","what":"Get help","title":"Machine-learning-enhanced QCA","text":"Please address questions bug reports : mlQCA issues.","code":""},{"path":"https://qinhuang-poliecon.github.io/mlQCA/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Machine-learning-enhanced QCA","text":"mlQCA: Machine-Learning Enhanced QCA R Package (progress) (2023) https://doi.org/XXXXXXXXXXXXXXXXXX","code":""},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/buildXGboost.html","id":null,"dir":"Reference","previous_headings":"","what":"buildXGboost — buildXGboost","title":"buildXGboost — buildXGboost","text":"wrapper around caret xgboost quickly build xgboost model","code":""},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/buildXGboost.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"buildXGboost — buildXGboost","text":"","code":"buildXGboost(data, outcome, customGrid = NULL)"},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/buildXGboost.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"buildXGboost — buildXGboost","text":"data input dataframe outcome string, name label column customGrid tune grid constructed [expand.grid()], specified, preset tune grid used","code":""},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/buildXGboost.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"buildXGboost — buildXGboost","text":"caret model object contains best-tuned xgboost model","code":""},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/buildXGboost.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"buildXGboost — buildXGboost","text":"","code":"if (FALSE) { xgbModel <- buildXGboost(voteDf, \"vote\")  # the following grid is used in default if no custom grid is specified myGrid <- expand.grid(eta=c(0.2:0.4),                         gamma=0,                         max_depth=c(3:5),                         colsample_bytree=c(0.6,0.8, 1),                         min_child_weight=1,                         subsample=c(0.75, 0.85,1),                         nrounds=c(50,100,150))  xgbModel <- buildXGboost(voteDf, \"vote\", customGrid = myGrid) }"},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/getAccXGboost.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate the accuracy of the trained xgboost model — getAccXGboost","title":"Estimate the accuracy of the trained xgboost model — getAccXGboost","text":"Estimate accuracy trained xgboost model","code":""},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/getAccXGboost.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate the accuracy of the trained xgboost model — getAccXGboost","text":"","code":"getAccXGboost(model, data, outcome)"},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/getAccXGboost.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate the accuracy of the trained xgboost model — getAccXGboost","text":"model output xgboost model `buildXGboost()` data dataframe, input data used train model outcome string, name outcome variable","code":""},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/getAccXGboost.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate the accuracy of the trained xgboost model — getAccXGboost","text":"number 0 1 indicating accuracy model (1 perfect accuracy)","code":""},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/getAccXGboost.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate the accuracy of the trained xgboost model — getAccXGboost","text":"","code":"if (FALSE) { getAccXGboost(xgb, voteData, \"vote\") }"},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/getFeatureImp.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate feature importance in terms of xgboost metrics and shap values — getFeatureImp","title":"Calculate feature importance in terms of xgboost metrics and shap values — getFeatureImp","text":"Calculate feature importance terms xgboost metrics shap values","code":""},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/getFeatureImp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate feature importance in terms of xgboost metrics and shap values — getFeatureImp","text":"","code":"getFeatureImp(model, data, outcome)"},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/getFeatureImp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate feature importance in terms of xgboost metrics and shap values — getFeatureImp","text":"model output xgboost model `buildXGboost()` data dataframe, input data used train model outcome string, name outcome variable","code":""},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/getFeatureImp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate feature importance in terms of xgboost metrics and shap values — getFeatureImp","text":"data frame contains 4 metrics feature Gain: improvement accuracy brought feature branches Cover: relative quantity observations concerned feature Frequency: number times feature used generated trees shap: average Shapley value feature","code":""},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/getFeatureImp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate feature importance in terms of xgboost metrics and shap values — getFeatureImp","text":"","code":"if (FALSE) { getFeatureImp(xgb, voteData, \"vote\") }"},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/getQCAMetric.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate per-variable QCA metric — getQCAMetric","title":"Calculate per-variable QCA metric — getQCAMetric","text":"Calculate per-variable QCA metric","code":""},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/getQCAMetric.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate per-variable QCA metric — getQCAMetric","text":"","code":"getQCAMetric(dataCali, outcome)"},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/getQCAMetric.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate per-variable QCA metric — getQCAMetric","text":"dataCali dataframe, calibrated data outcome string, name outcome variable","code":""},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/getQCAMetric.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate per-variable QCA metric — getQCAMetric","text":"data frame contains 3 QCA metrics Cons.Nec: necessity consistency Cov.Nec: necessity coverage RoN: relavance necessity","code":""},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/getQCAMetric.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate per-variable QCA metric — getQCAMetric","text":"","code":"if (FALSE) { getQCAMetric(voteDataCalibrated, \"vote\") }"},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/getXGboostCut.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract the cutoffs used in the trained xgboost model — getXGboostCut","title":"Extract the cutoffs used in the trained xgboost model — getXGboostCut","text":"Extract cutoffs used trained xgboost model","code":""},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/getXGboostCut.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract the cutoffs used in the trained xgboost model — getXGboostCut","text":"","code":"getXGboostCut(model, full = F, treeIndex = NULL)"},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/getXGboostCut.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract the cutoffs used in the trained xgboost model — getXGboostCut","text":"model output xgboost model `buildXGboost()` full logical, whether report frequent cutoff feautres cutoffs (default: False) treeIndex number, examine cutoffs particular tree","code":""},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/getXGboostCut.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract the cutoffs used in the trained xgboost model — getXGboostCut","text":"dataframe contains cutoffs used xgboost model feature","code":""},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/getXGboostCut.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract the cutoffs used in the trained xgboost model — getXGboostCut","text":"","code":"if (FALSE) { getXGboostCut(xgb) }"},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/iterQCA.html","id":null,"dir":"Reference","previous_headings":"","what":"Iteratively do sufficiency tests on k features out of the given features — iterQCA","title":"Iteratively do sufficiency tests on k features out of the given features — iterQCA","text":"function iteratively generates combinations k features given feature vector (n choose k), perform sufficiency test combination k features.","code":""},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/iterQCA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Iteratively do sufficiency tests on k features out of the given features — iterQCA","text":"","code":"iterQCA(   features,   k,   dataCali,   outcome,   incl.cut = 0.8,   pri.cut = 0.51,   n.cut = 10,   sort.by = c(\"OUT\", \"incl\"),   complete = T )"},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/iterQCA.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Iteratively do sufficiency tests on k features out of the given features — iterQCA","text":"features string vector, vector features choose k number, number features choose sufficiency test dataCali dataframe, calibrated data outcome string, name outcome variable incl.cut inclusion cut-(s); see `?QCA::truthTable` details pri.cut minimal score PRI; see `?QCA::truthTable` details n.cut minimum number cases remainder row; see `?QCA::truthTable` details sort.Sort truth table according various columns complete Logical, whether print complete truth table","code":""},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/iterQCA.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Iteratively do sufficiency tests on k features out of the given features — iterQCA","text":"summary table solutions combinations k n feautres","code":""},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/iterQCA.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Iteratively do sufficiency tests on k features out of the given features — iterQCA","text":"","code":"if (FALSE) { fDf <- getFeatureImp(xgb, voteData, \"vote\") fVec <- head(fDf$feature, 10) iterQCA(features = fVec, k=4, dataCali = voteDataCalibrated, outcome = \"vote\") }"},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/joinMetrics.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper function to join the feature-level QCA and XGboost metrics — joinMetrics","title":"Helper function to join the feature-level QCA and XGboost metrics — joinMetrics","text":"Helper function join feature-level QCA XGboost metrics","code":""},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/joinMetrics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper function to join the feature-level QCA and XGboost metrics — joinMetrics","text":"","code":"joinMetrics(featureMetric, qcaMetric)"},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/joinMetrics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper function to join the feature-level QCA and XGboost metrics — joinMetrics","text":"featureMetric dataframe, result `getQCAMetric()` qcaMetric dataframe, result `getFeatureImp()`","code":""},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/joinMetrics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper function to join the feature-level QCA and XGboost metrics — joinMetrics","text":"dataframe, combined dataframe feature-level importance","code":""},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/joinMetrics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Helper function to join the feature-level QCA and XGboost metrics — joinMetrics","text":"","code":"if (FALSE) { fDf <- getFeatureImp(xgb, voteData, \"vote\") qDf <- getQCAMetric(voteDataCalibrated, \"vote\") joinDf <- joinMetrics(fDf, qDf) }"},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/mlQCA-package.html","id":null,"dir":"Reference","previous_headings":"","what":"mlQCA: Machine-learning-enhanced QCA — mlQCA-package","title":"mlQCA: Machine-learning-enhanced QCA — mlQCA-package","text":"Deploying machine learning feature-selection calibration downstream QCA analysis Current version uses xgboost main model machine learning.","code":""},{"path":[]},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/reCalibrateXGCut.html","id":null,"dir":"Reference","previous_headings":"","what":"Calibrate data based on xgboost model cutoffs — reCalibrateXGCut","title":"Calibrate data based on xgboost model cutoffs — reCalibrateXGCut","text":"function performs crisp calibration based set cutoffs derived xgboost trees","code":""},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/reCalibrateXGCut.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calibrate data based on xgboost model cutoffs — reCalibrateXGCut","text":"","code":"reCalibrateXGCut(data, cutoffs, outcome, na.rm = T)"},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/reCalibrateXGCut.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calibrate data based on xgboost model cutoffs — reCalibrateXGCut","text":"data input data used train xgboost model cutoffs dataframe, contains cutoffs extracted trained xgboost model outcome string, indicates name outcome variable na.rm logical, whether remove rows contain NA calibration (default: True)","code":""},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/reCalibrateXGCut.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calibrate data based on xgboost model cutoffs — reCalibrateXGCut","text":"calibrated dataframe","code":""},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/reCalibrateXGCut.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calibrate data based on xgboost model cutoffs — reCalibrateXGCut","text":"","code":"if (FALSE) { reCalibrateXGCut(voteData, cutDataFrame, \"vote\") }"},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/subsetSuffiTest.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform sufficiency test on a select set of variables — subsetSuffiTest","title":"Perform sufficiency test on a select set of variables — subsetSuffiTest","text":"Perform sufficiency test select set variables","code":""},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/subsetSuffiTest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform sufficiency test on a select set of variables — subsetSuffiTest","text":"","code":"subsetSuffiTest(   dataCali,   vSelect,   outcome,   incl.cut = 0.8,   pri.cut = 0.51,   n.cut = 10,   sort.by = c(\"OUT\", \"incl\"),   complete = T )"},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/subsetSuffiTest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform sufficiency test on a select set of variables — subsetSuffiTest","text":"dataCali dataframe, calibrated data vSelect string vector, selected variable names (must dataCali) outcome string, name outcome variable incl.cut inclusion cut-(s); see `?QCA::truthTable` details pri.cut minimal score PRI; see `?QCA::truthTable` details n.cut minimum number cases remainder row; see `?QCA::truthTable` details sort.Sort truth table according various columns complete Logical, whether print complete truth table","code":""},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/subsetSuffiTest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform sufficiency test on a select set of variables — subsetSuffiTest","text":"list two tables table: truth table path: sufficiency test solution","code":""},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/subsetSuffiTest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Perform sufficiency test on a select set of variables — subsetSuffiTest","text":"","code":"if (FALSE) { subsetSuffiTest(voteDataCalibrated, c(\"P_V530\", \"V648\", \"V207\", \"V141\"), \"vote\") }"},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/sumSuffTestRes.html","id":null,"dir":"Reference","previous_headings":"","what":"helper function to combine results from a series of sufficiency tests — sumSuffTestRes","title":"helper function to combine results from a series of sufficiency tests — sumSuffTestRes","text":"helper function combine results series sufficiency tests","code":""},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/sumSuffTestRes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"helper function to combine results from a series of sufficiency tests — sumSuffTestRes","text":"","code":"sumSuffTestRes(featureList, resList)"},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/sumSuffTestRes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"helper function to combine results from a series of sufficiency tests — sumSuffTestRes","text":"featureList list feature vectors resList list corresponding results `subsetSuffiTest()` featureList","code":""},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/sumSuffTestRes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"helper function to combine results from a series of sufficiency tests — sumSuffTestRes","text":"dataframe, summarizes results sufficiency tests","code":""},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/voteData.html","id":null,"dir":"Reference","previous_headings":"","what":"panel data of youth voting — voteData","title":"panel data of youth voting — voteData","text":"subset data World Health Organization Global Tuberculosis Report ...","code":""},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/voteData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"panel data of youth voting — voteData","text":"","code":"voteData"},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/voteData.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"panel data of youth voting — voteData","text":"## `voteData` data frame 427 rows 77 columns: vote whether person voted ","code":""},{"path":"https://qinhuang-poliecon.github.io/mlQCA/reference/voteData.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"panel data of youth voting — voteData","text":"<https://www..int/teams/global-tuberculosis-programme/data>","code":""}]
